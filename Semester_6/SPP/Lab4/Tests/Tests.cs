namespace Tests;

using FluentAssertions;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Reflection;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Generator;

[TestClass]
public class Tests
{
    private string testClassView = "";

    [TestInitialize]
    public void testInitialize()
    {
        var basePath = AppDomain.CurrentDomain.BaseDirectory;
        basePath = Directory.GetParent(basePath)!.FullName;
        basePath = Directory.GetParent(basePath)!.FullName;
        basePath = Directory.GetParent(basePath)!.FullName;
        basePath = Directory.GetParent(basePath)!.FullName;
        var filePath = Path.Combine(basePath, "MyClass.cs");
        var generator = new Generator();
        var namesAndContents = generator.getNamesAndContents(File.ReadAllText(filePath));
        testClassView = namesAndContents.Result.Values.ElementAt(0);
    }

    [TestMethod]
    public void testVoidMethod()
    {
        var voidMethod = "[Test]\r\n        public void testTest() {\r\n            int b = default(int);\r\n            Assert.DoesNotThrow(() => { _myClassUnderTest.test(b); });\r\n            Assert.Fail(\"autogenerated\");\r\n        }";
        var commonMethod = "[Test]\r\n        public void testTest() {\r\n            a = new Mock<IDataReader>();\r\n            int b = default(int);\r\n            int c = default(int);\r\n            int actual = _myClassUnderTest.test(a.Object, b, c);\r\n            int expected = default(int);\r\n            Assert.That(actual, Is.EqualTo(expected));\r\n            Assert.Fail(\"autogenerated\");\r\n        }";
        var setUpMethod = "[SetUp]\r\n        public void SetUp() {\r\n            _dependency1 = new Mock<IDataReader>();\r\n            _dependency2 = new Mock<ICloneable>();\r\n            string param1 = default(string);\r\n            _myClassUnderTest = new Class1(_dependency1.Object, _dependency2.Object, param1);\r\n        }";
        testClassView.Should().Contain(voidMethod);
        testClassView.Should().Contain(commonMethod);
        testClassView.Should().Contain(setUpMethod);
    }

    [TestMethod]
    public void testMethodsAmount()
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(testClassView);
        var root = syntaxTree.GetRoot();
        var compilation = CSharpCompilation.Create("MyCompilation").AddSyntaxTrees(syntaxTree);
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        var methods = root.DescendantNodes().OfType<MethodDeclarationSyntax>();
        var type = typeof(Class1);
        var quantity = type.GetMethods(BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Length;
        quantity.Should().Be(methods.Count() - 1);
    }
}